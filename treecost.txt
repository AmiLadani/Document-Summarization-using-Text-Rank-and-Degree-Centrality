#include<bits/stdc++.h>
using namespace std;
int costofatree(vector<int>vect)
{
    int n=vect.size();
    int dp[n][n];
    for(int i=0;i<n;i++)
    {
        dp[i][i]=0;
    }
    for(int l=2;l<=n;l++)
    {
        for(int i=0;i<n-l+1;i++)
        {
            int j=i+l-1;
            dp[i][j]=INT_MAX;
            for(int k=i;k<j;k++)
            {
                int x=dp[i][k]+dp[k+1][j]+*max_element(vect.begin()+i,vect.begin()+k+1)*(*max_element(vect.begin()+k+1,vect.begin()+j+1));
                dp[i][j]=min(dp[i][j],x);
            }
        }
    }
    return dp[0][n-1];
}
int main()
{
vector<int> b={4,6,2};
cout<< costofatree(b);
}

//////////////////////////////////////////////////////////////////////https://www.geeksforgeeks.org/count-sub-arrays-sum-divisible-k/
// Java program to find count of 
// subarrays with sum divisible by k. 
import java.util.*; 
  
class GFG { 
  
    // Handles all the cases 
    // function to find all sub-arrays divisible by k 
    // modified to handle negative numbers as well 
    static int subCount(int arr[], int n, int k) 
    { 
  
        // create auxiliary hash array to 
        // count frequency of remainders 
        int mod[] = new int[k]; 
        Arrays.fill(mod, 0); 
  
        // Traverse original array and compute cumulative 
        // sum take remainder of this current cumulative 
        // sum and increase count by 1 for this remainder 
        // in mod[] array 
        int cumSum = 0; 
        for (int i = 0; i < n; i++) { 
            cumSum += arr[i]; 
  
            // as the sum can be negative, taking modulo twice 
            mod[((cumSum % k) + k) % k]++; 
        } 
  
        // Initialize result 
        int result = 0; 
  
        // Traverse mod[] 
        for (int i = 0; i < k; i++) 
  
            // If there are more than one prefix subarrays 
            // with a particular mod value. 
            if (mod[i] > 1) 
                result += (mod[i] * (mod[i] - 1)) / 2; 
  
        // add the elements which are divisible by k itself 
        // i.e., the elements whose sum = 0 
        result += mod[0]; 
  
        return result; 
    } 
  
    // Driver code 
    public static void main(String[] args) 
    { 
  
        int arr[] = { 4, 5, 0, -2, -3, 1 }; 
        int k = 5; 
        int n = arr.length; 
        System.out.println(subCount(arr, n, k)); 
        int arr1[] = { 4, 5, 0, -12, -23, 1 }; 
        int k1 = 5; 
        int n1 = arr1.length; 
        System.out.println(subCount(arr1, n1, k1)); 
    } 
} 
https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/
/* A Naive recursive implementation of 0-1 Knapsack problem */
class Knapsack 
{ 
  
    // A utility function that returns maximum of two integers 
     static int max(int a, int b) { return (a > b)? a : b; } 
       
     // Returns the maximum value that can be put in a knapsack of capacity W 
     static int knapSack(int W, int wt[], int val[], int n) 
     { 
        // Base Case 
    if (n == 0 || W == 0) 
        return 0; 
       
    // If weight of the nth item is more than Knapsack capacity W, then 
    // this item cannot be included in the optimal solution 
    if (wt[n-1] > W) 
       return knapSack(W, wt, val, n-1); 
       
    // Return the maximum of two cases:  
    // (1) nth item included  
    // (2) not included 
    else return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1), 
                     knapSack(W, wt, val, n-1) 
                      ); 
  }   
   // Driver program to test above function 
   public static void main(String args[]) 
   { 
        int val[] = new int[]{60, 100, 120}; 
        int wt[] = new int[]{10, 20, 30}; 
    int  W = 50; 
    int n = val.length; 
    System.out.println(knapSack(W, wt, val, n)); 
    } 
} 
https://www.geeksforgeeks.org/replace-duplicates-with-greater-than-previous-duplicate-value/
// CPP program to replace every repeating 
// element with next greater element. 
#include <bits/stdc++.h> 
using namespace std; 
  
void replaceElements(int arr[], int n) 
{ 
    unordered_set<int> s; 
  
    for (int i = 0; i < n; i++) { 
  
        // check whether the element is 
        // repeated or not 
        if (s.find(arr[i]) == s.end()) 
            s.insert(arr[i]); 
  
        else { 
  
            // find the next greatest element 
            for (int j = arr[i] + 1; j < INT_MAX; j++) { 
                if (s.find(j) == s.end()) { 
                    arr[i] = j; 
                    s.insert(j); 
                    break; 
                } 
            } 
        } 
    } 
} 
  
int main() 
{ 
    int arr[] = { 1, 2, 5, 7, 8, 8, 7 }; 
    int n = sizeof(arr)/sizeof(arr[0]); 
  
    replaceElements(arr, n); 
  
    for (int i = 0; i < n; i++) 
        cout << arr[i] << " "; 
    cout << "\n"; 
} 
https://ideone.com/K7i9LB      https://stackoverflow.com/questions/9493853/given-an-array-find-out-the-next-smaller-element-for-each-element
#include <bits/stdc++.h> 
using namespace std; 
 
void smallestGreater(int arr[], int n) 
{ 
	set<int> s; 
	for (int i = 0; i < n; i++) 
	s.insert(arr[i]); 
 
	for (int i = 0; i < n; i++) 
	{ 
		auto it = s.find(arr[i]); 
 
		if (it == s.begin())            
          cout << "_" << " ";        
    	else
    	{
        it--;  cout << *it<<" "; 
    	}
    	s.erase(arr[i]);
	} 
} 
 
// Driver code 
int main() 
{ 
	int ar[] = { 6, 3, 9, 8, 10, 2, 1, 15, 7 }; 
	int n = sizeof(ar) / sizeof(ar[0]); 
	smallestGreater(ar, n); 
	return 0; 
} 
https://stackoverflow.com/questions/38539213/find-the-least-greater-element-on-the-right
  
